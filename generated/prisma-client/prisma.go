// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:7007"
var Secret = ""

func (client *Client) Company(params CompanyWhereUniqueInput) *CompanyExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CompanyWhereUniqueInput!", "Company"},
		"company",
		[]string{"id", "name"})

	return &CompanyExec{ret}
}

type CompaniesParams struct {
	Where   *CompanyWhereInput   `json:"where,omitempty"`
	OrderBy *CompanyOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Companies(params *CompaniesParams) *CompanyExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CompanyWhereInput", "CompanyOrderByInput", "Company"},
		"companies",
		[]string{"id", "name"})

	return &CompanyExecArray{ret}
}

type CompaniesConnectionParams struct {
	Where   *CompanyWhereInput   `json:"where,omitempty"`
	OrderBy *CompanyOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *CompanyConnection) Nodes() []Company {
	var nodes []Company
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *CompanyConnection) NodesPtr() []*Company {
	var nodes []*Company
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) CompaniesConnection(params *CompaniesConnectionParams) *CompanyConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CompanyWhereInput", "CompanyOrderByInput", "Company"},
		"companiesConnection",
		[]string{"edges", "pageInfo"})

	return &CompanyConnectionExec{ret}
}

func (client *Client) Content(params ContentWhereUniqueInput) *ContentExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ContentWhereUniqueInput!", "Content"},
		"content",
		[]string{"id", "title", "text", "category", "type", "limit", "note", "opt", "createdBy", "updatedBy", "image", "createdAt", "updatedAt"})

	return &ContentExec{ret}
}

type ContentsParams struct {
	Where   *ContentWhereInput   `json:"where,omitempty"`
	OrderBy *ContentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Contents(params *ContentsParams) *ContentExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ContentWhereInput", "ContentOrderByInput", "Content"},
		"contents",
		[]string{"id", "title", "text", "category", "type", "limit", "note", "opt", "createdBy", "updatedBy", "image", "createdAt", "updatedAt"})

	return &ContentExecArray{ret}
}

type ContentsConnectionParams struct {
	Where   *ContentWhereInput   `json:"where,omitempty"`
	OrderBy *ContentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ContentConnection) Nodes() []Content {
	var nodes []Content
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ContentConnection) NodesPtr() []*Content {
	var nodes []*Content
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ContentsConnection(params *ContentsConnectionParams) *ContentConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ContentWhereInput", "ContentOrderByInput", "Content"},
		"contentsConnection",
		[]string{"edges", "pageInfo"})

	return &ContentConnectionExec{ret}
}

func (client *Client) Person(params PersonWhereUniqueInput) *PersonExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PersonWhereUniqueInput!", "Person"},
		"person",
		[]string{"id", "name", "email", "password", "createdAt"})

	return &PersonExec{ret}
}

type PersonsParams struct {
	Where   *PersonWhereInput   `json:"where,omitempty"`
	OrderBy *PersonOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) Persons(params *PersonsParams) *PersonExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PersonWhereInput", "PersonOrderByInput", "Person"},
		"persons",
		[]string{"id", "name", "email", "password", "createdAt"})

	return &PersonExecArray{ret}
}

type PersonsConnectionParams struct {
	Where   *PersonWhereInput   `json:"where,omitempty"`
	OrderBy *PersonOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *PersonConnection) Nodes() []Person {
	var nodes []Person
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *PersonConnection) NodesPtr() []*Person {
	var nodes []*Person
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) PersonsConnection(params *PersonsConnectionParams) *PersonConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PersonWhereInput", "PersonOrderByInput", "Person"},
		"personsConnection",
		[]string{"edges", "pageInfo"})

	return &PersonConnectionExec{ret}
}

func (client *Client) CreateCompany(params CompanyCreateInput) *CompanyExec {
	ret := client.Client.Create(
		params,
		[2]string{"CompanyCreateInput!", "Company"},
		"createCompany",
		[]string{"id", "name"})

	return &CompanyExec{ret}
}

type CompanyUpdateParams struct {
	Data  CompanyUpdateInput      `json:"data"`
	Where CompanyWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCompany(params CompanyUpdateParams) *CompanyExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CompanyUpdateInput!", "CompanyWhereUniqueInput!", "Company"},
		"updateCompany",
		[]string{"id", "name"})

	return &CompanyExec{ret}
}

type CompanyUpdateManyParams struct {
	Data  CompanyUpdateManyMutationInput `json:"data"`
	Where *CompanyWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCompanies(params CompanyUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CompanyUpdateManyMutationInput!", "CompanyWhereInput"},
		"updateManyCompanies")
	return &BatchPayloadExec{exec}
}

type CompanyUpsertParams struct {
	Where  CompanyWhereUniqueInput `json:"where"`
	Create CompanyCreateInput      `json:"create"`
	Update CompanyUpdateInput      `json:"update"`
}

func (client *Client) UpsertCompany(params CompanyUpsertParams) *CompanyExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CompanyWhereUniqueInput!", "CompanyCreateInput!", "CompanyUpdateInput!", "Company"},
		"upsertCompany",
		[]string{"id", "name"})

	return &CompanyExec{ret}
}

func (client *Client) DeleteCompany(params CompanyWhereUniqueInput) *CompanyExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CompanyWhereUniqueInput!", "Company"},
		"deleteCompany",
		[]string{"id", "name"})

	return &CompanyExec{ret}
}

func (client *Client) DeleteManyCompanies(params *CompanyWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CompanyWhereInput", "deleteManyCompanies")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateContent(params ContentCreateInput) *ContentExec {
	ret := client.Client.Create(
		params,
		[2]string{"ContentCreateInput!", "Content"},
		"createContent",
		[]string{"id", "title", "text", "category", "type", "limit", "note", "opt", "createdBy", "updatedBy", "image", "createdAt", "updatedAt"})

	return &ContentExec{ret}
}

type ContentUpdateParams struct {
	Data  ContentUpdateInput      `json:"data"`
	Where ContentWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateContent(params ContentUpdateParams) *ContentExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ContentUpdateInput!", "ContentWhereUniqueInput!", "Content"},
		"updateContent",
		[]string{"id", "title", "text", "category", "type", "limit", "note", "opt", "createdBy", "updatedBy", "image", "createdAt", "updatedAt"})

	return &ContentExec{ret}
}

type ContentUpdateManyParams struct {
	Data  ContentUpdateManyMutationInput `json:"data"`
	Where *ContentWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyContents(params ContentUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ContentUpdateManyMutationInput!", "ContentWhereInput"},
		"updateManyContents")
	return &BatchPayloadExec{exec}
}

type ContentUpsertParams struct {
	Where  ContentWhereUniqueInput `json:"where"`
	Create ContentCreateInput      `json:"create"`
	Update ContentUpdateInput      `json:"update"`
}

func (client *Client) UpsertContent(params ContentUpsertParams) *ContentExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ContentWhereUniqueInput!", "ContentCreateInput!", "ContentUpdateInput!", "Content"},
		"upsertContent",
		[]string{"id", "title", "text", "category", "type", "limit", "note", "opt", "createdBy", "updatedBy", "image", "createdAt", "updatedAt"})

	return &ContentExec{ret}
}

func (client *Client) DeleteContent(params ContentWhereUniqueInput) *ContentExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ContentWhereUniqueInput!", "Content"},
		"deleteContent",
		[]string{"id", "title", "text", "category", "type", "limit", "note", "opt", "createdBy", "updatedBy", "image", "createdAt", "updatedAt"})

	return &ContentExec{ret}
}

func (client *Client) DeleteManyContents(params *ContentWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ContentWhereInput", "deleteManyContents")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePerson(params PersonCreateInput) *PersonExec {
	ret := client.Client.Create(
		params,
		[2]string{"PersonCreateInput!", "Person"},
		"createPerson",
		[]string{"id", "name", "email", "password", "createdAt"})

	return &PersonExec{ret}
}

type PersonUpdateParams struct {
	Data  PersonUpdateInput      `json:"data"`
	Where PersonWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePerson(params PersonUpdateParams) *PersonExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PersonUpdateInput!", "PersonWhereUniqueInput!", "Person"},
		"updatePerson",
		[]string{"id", "name", "email", "password", "createdAt"})

	return &PersonExec{ret}
}

type PersonUpdateManyParams struct {
	Data  PersonUpdateManyMutationInput `json:"data"`
	Where *PersonWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPersons(params PersonUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PersonUpdateManyMutationInput!", "PersonWhereInput"},
		"updateManyPersons")
	return &BatchPayloadExec{exec}
}

type PersonUpsertParams struct {
	Where  PersonWhereUniqueInput `json:"where"`
	Create PersonCreateInput      `json:"create"`
	Update PersonUpdateInput      `json:"update"`
}

func (client *Client) UpsertPerson(params PersonUpsertParams) *PersonExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PersonWhereUniqueInput!", "PersonCreateInput!", "PersonUpdateInput!", "Person"},
		"upsertPerson",
		[]string{"id", "name", "email", "password", "createdAt"})

	return &PersonExec{ret}
}

func (client *Client) DeletePerson(params PersonWhereUniqueInput) *PersonExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PersonWhereUniqueInput!", "Person"},
		"deletePerson",
		[]string{"id", "name", "email", "password", "createdAt"})

	return &PersonExec{ret}
}

func (client *Client) DeleteManyPersons(params *PersonWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PersonWhereInput", "deleteManyPersons")
	return &BatchPayloadExec{exec}
}

type CompanyOrderByInput string

const (
	CompanyOrderByInputIDAsc    CompanyOrderByInput = "id_ASC"
	CompanyOrderByInputIDDesc   CompanyOrderByInput = "id_DESC"
	CompanyOrderByInputNameAsc  CompanyOrderByInput = "name_ASC"
	CompanyOrderByInputNameDesc CompanyOrderByInput = "name_DESC"
)

type ContentOrderByInput string

const (
	ContentOrderByInputIDAsc         ContentOrderByInput = "id_ASC"
	ContentOrderByInputIDDesc        ContentOrderByInput = "id_DESC"
	ContentOrderByInputTitleAsc      ContentOrderByInput = "title_ASC"
	ContentOrderByInputTitleDesc     ContentOrderByInput = "title_DESC"
	ContentOrderByInputTextAsc       ContentOrderByInput = "text_ASC"
	ContentOrderByInputTextDesc      ContentOrderByInput = "text_DESC"
	ContentOrderByInputCategoryAsc   ContentOrderByInput = "category_ASC"
	ContentOrderByInputCategoryDesc  ContentOrderByInput = "category_DESC"
	ContentOrderByInputTypeAsc       ContentOrderByInput = "type_ASC"
	ContentOrderByInputTypeDesc      ContentOrderByInput = "type_DESC"
	ContentOrderByInputLimitAsc      ContentOrderByInput = "limit_ASC"
	ContentOrderByInputLimitDesc     ContentOrderByInput = "limit_DESC"
	ContentOrderByInputNoteAsc       ContentOrderByInput = "note_ASC"
	ContentOrderByInputNoteDesc      ContentOrderByInput = "note_DESC"
	ContentOrderByInputOptAsc        ContentOrderByInput = "opt_ASC"
	ContentOrderByInputOptDesc       ContentOrderByInput = "opt_DESC"
	ContentOrderByInputCreatedByAsc  ContentOrderByInput = "createdBy_ASC"
	ContentOrderByInputCreatedByDesc ContentOrderByInput = "createdBy_DESC"
	ContentOrderByInputUpdatedByAsc  ContentOrderByInput = "updatedBy_ASC"
	ContentOrderByInputUpdatedByDesc ContentOrderByInput = "updatedBy_DESC"
	ContentOrderByInputImageAsc      ContentOrderByInput = "image_ASC"
	ContentOrderByInputImageDesc     ContentOrderByInput = "image_DESC"
	ContentOrderByInputCreatedAtAsc  ContentOrderByInput = "createdAt_ASC"
	ContentOrderByInputCreatedAtDesc ContentOrderByInput = "createdAt_DESC"
	ContentOrderByInputUpdatedAtAsc  ContentOrderByInput = "updatedAt_ASC"
	ContentOrderByInputUpdatedAtDesc ContentOrderByInput = "updatedAt_DESC"
)

type PersonOrderByInput string

const (
	PersonOrderByInputIDAsc         PersonOrderByInput = "id_ASC"
	PersonOrderByInputIDDesc        PersonOrderByInput = "id_DESC"
	PersonOrderByInputNameAsc       PersonOrderByInput = "name_ASC"
	PersonOrderByInputNameDesc      PersonOrderByInput = "name_DESC"
	PersonOrderByInputEmailAsc      PersonOrderByInput = "email_ASC"
	PersonOrderByInputEmailDesc     PersonOrderByInput = "email_DESC"
	PersonOrderByInputPasswordAsc   PersonOrderByInput = "password_ASC"
	PersonOrderByInputPasswordDesc  PersonOrderByInput = "password_DESC"
	PersonOrderByInputCreatedAtAsc  PersonOrderByInput = "createdAt_ASC"
	PersonOrderByInputCreatedAtDesc PersonOrderByInput = "createdAt_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type CompanyWhereUniqueInput struct {
	ID   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

type CompanyWhereInput struct {
	ID                *string             `json:"id,omitempty"`
	IDNot             *string             `json:"id_not,omitempty"`
	IDIn              []string            `json:"id_in,omitempty"`
	IDNotIn           []string            `json:"id_not_in,omitempty"`
	IDLt              *string             `json:"id_lt,omitempty"`
	IDLte             *string             `json:"id_lte,omitempty"`
	IDGt              *string             `json:"id_gt,omitempty"`
	IDGte             *string             `json:"id_gte,omitempty"`
	IDContains        *string             `json:"id_contains,omitempty"`
	IDNotContains     *string             `json:"id_not_contains,omitempty"`
	IDStartsWith      *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string             `json:"id_not_ends_with,omitempty"`
	Name              *string             `json:"name,omitempty"`
	NameNot           *string             `json:"name_not,omitempty"`
	NameIn            []string            `json:"name_in,omitempty"`
	NameNotIn         []string            `json:"name_not_in,omitempty"`
	NameLt            *string             `json:"name_lt,omitempty"`
	NameLte           *string             `json:"name_lte,omitempty"`
	NameGt            *string             `json:"name_gt,omitempty"`
	NameGte           *string             `json:"name_gte,omitempty"`
	NameContains      *string             `json:"name_contains,omitempty"`
	NameNotContains   *string             `json:"name_not_contains,omitempty"`
	NameStartsWith    *string             `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string             `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string             `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string             `json:"name_not_ends_with,omitempty"`
	And               []CompanyWhereInput `json:"AND,omitempty"`
	Or                []CompanyWhereInput `json:"OR,omitempty"`
	Not               []CompanyWhereInput `json:"NOT,omitempty"`
}

type ContentWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ContentWhereInput struct {
	ID                     *string             `json:"id,omitempty"`
	IDNot                  *string             `json:"id_not,omitempty"`
	IDIn                   []string            `json:"id_in,omitempty"`
	IDNotIn                []string            `json:"id_not_in,omitempty"`
	IDLt                   *string             `json:"id_lt,omitempty"`
	IDLte                  *string             `json:"id_lte,omitempty"`
	IDGt                   *string             `json:"id_gt,omitempty"`
	IDGte                  *string             `json:"id_gte,omitempty"`
	IDContains             *string             `json:"id_contains,omitempty"`
	IDNotContains          *string             `json:"id_not_contains,omitempty"`
	IDStartsWith           *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith        *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith             *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith          *string             `json:"id_not_ends_with,omitempty"`
	Title                  *string             `json:"title,omitempty"`
	TitleNot               *string             `json:"title_not,omitempty"`
	TitleIn                []string            `json:"title_in,omitempty"`
	TitleNotIn             []string            `json:"title_not_in,omitempty"`
	TitleLt                *string             `json:"title_lt,omitempty"`
	TitleLte               *string             `json:"title_lte,omitempty"`
	TitleGt                *string             `json:"title_gt,omitempty"`
	TitleGte               *string             `json:"title_gte,omitempty"`
	TitleContains          *string             `json:"title_contains,omitempty"`
	TitleNotContains       *string             `json:"title_not_contains,omitempty"`
	TitleStartsWith        *string             `json:"title_starts_with,omitempty"`
	TitleNotStartsWith     *string             `json:"title_not_starts_with,omitempty"`
	TitleEndsWith          *string             `json:"title_ends_with,omitempty"`
	TitleNotEndsWith       *string             `json:"title_not_ends_with,omitempty"`
	Text                   *string             `json:"text,omitempty"`
	TextNot                *string             `json:"text_not,omitempty"`
	TextIn                 []string            `json:"text_in,omitempty"`
	TextNotIn              []string            `json:"text_not_in,omitempty"`
	TextLt                 *string             `json:"text_lt,omitempty"`
	TextLte                *string             `json:"text_lte,omitempty"`
	TextGt                 *string             `json:"text_gt,omitempty"`
	TextGte                *string             `json:"text_gte,omitempty"`
	TextContains           *string             `json:"text_contains,omitempty"`
	TextNotContains        *string             `json:"text_not_contains,omitempty"`
	TextStartsWith         *string             `json:"text_starts_with,omitempty"`
	TextNotStartsWith      *string             `json:"text_not_starts_with,omitempty"`
	TextEndsWith           *string             `json:"text_ends_with,omitempty"`
	TextNotEndsWith        *string             `json:"text_not_ends_with,omitempty"`
	Category               *string             `json:"category,omitempty"`
	CategoryNot            *string             `json:"category_not,omitempty"`
	CategoryIn             []string            `json:"category_in,omitempty"`
	CategoryNotIn          []string            `json:"category_not_in,omitempty"`
	CategoryLt             *string             `json:"category_lt,omitempty"`
	CategoryLte            *string             `json:"category_lte,omitempty"`
	CategoryGt             *string             `json:"category_gt,omitempty"`
	CategoryGte            *string             `json:"category_gte,omitempty"`
	CategoryContains       *string             `json:"category_contains,omitempty"`
	CategoryNotContains    *string             `json:"category_not_contains,omitempty"`
	CategoryStartsWith     *string             `json:"category_starts_with,omitempty"`
	CategoryNotStartsWith  *string             `json:"category_not_starts_with,omitempty"`
	CategoryEndsWith       *string             `json:"category_ends_with,omitempty"`
	CategoryNotEndsWith    *string             `json:"category_not_ends_with,omitempty"`
	Type                   *string             `json:"type,omitempty"`
	TypeNot                *string             `json:"type_not,omitempty"`
	TypeIn                 []string            `json:"type_in,omitempty"`
	TypeNotIn              []string            `json:"type_not_in,omitempty"`
	TypeLt                 *string             `json:"type_lt,omitempty"`
	TypeLte                *string             `json:"type_lte,omitempty"`
	TypeGt                 *string             `json:"type_gt,omitempty"`
	TypeGte                *string             `json:"type_gte,omitempty"`
	TypeContains           *string             `json:"type_contains,omitempty"`
	TypeNotContains        *string             `json:"type_not_contains,omitempty"`
	TypeStartsWith         *string             `json:"type_starts_with,omitempty"`
	TypeNotStartsWith      *string             `json:"type_not_starts_with,omitempty"`
	TypeEndsWith           *string             `json:"type_ends_with,omitempty"`
	TypeNotEndsWith        *string             `json:"type_not_ends_with,omitempty"`
	Limit                  *int32              `json:"limit,omitempty"`
	LimitNot               *int32              `json:"limit_not,omitempty"`
	LimitIn                []int32             `json:"limit_in,omitempty"`
	LimitNotIn             []int32             `json:"limit_not_in,omitempty"`
	LimitLt                *int32              `json:"limit_lt,omitempty"`
	LimitLte               *int32              `json:"limit_lte,omitempty"`
	LimitGt                *int32              `json:"limit_gt,omitempty"`
	LimitGte               *int32              `json:"limit_gte,omitempty"`
	Note                   *string             `json:"note,omitempty"`
	NoteNot                *string             `json:"note_not,omitempty"`
	NoteIn                 []string            `json:"note_in,omitempty"`
	NoteNotIn              []string            `json:"note_not_in,omitempty"`
	NoteLt                 *string             `json:"note_lt,omitempty"`
	NoteLte                *string             `json:"note_lte,omitempty"`
	NoteGt                 *string             `json:"note_gt,omitempty"`
	NoteGte                *string             `json:"note_gte,omitempty"`
	NoteContains           *string             `json:"note_contains,omitempty"`
	NoteNotContains        *string             `json:"note_not_contains,omitempty"`
	NoteStartsWith         *string             `json:"note_starts_with,omitempty"`
	NoteNotStartsWith      *string             `json:"note_not_starts_with,omitempty"`
	NoteEndsWith           *string             `json:"note_ends_with,omitempty"`
	NoteNotEndsWith        *string             `json:"note_not_ends_with,omitempty"`
	Opt                    *string             `json:"opt,omitempty"`
	OptNot                 *string             `json:"opt_not,omitempty"`
	OptIn                  []string            `json:"opt_in,omitempty"`
	OptNotIn               []string            `json:"opt_not_in,omitempty"`
	OptLt                  *string             `json:"opt_lt,omitempty"`
	OptLte                 *string             `json:"opt_lte,omitempty"`
	OptGt                  *string             `json:"opt_gt,omitempty"`
	OptGte                 *string             `json:"opt_gte,omitempty"`
	OptContains            *string             `json:"opt_contains,omitempty"`
	OptNotContains         *string             `json:"opt_not_contains,omitempty"`
	OptStartsWith          *string             `json:"opt_starts_with,omitempty"`
	OptNotStartsWith       *string             `json:"opt_not_starts_with,omitempty"`
	OptEndsWith            *string             `json:"opt_ends_with,omitempty"`
	OptNotEndsWith         *string             `json:"opt_not_ends_with,omitempty"`
	CreatedBy              *string             `json:"createdBy,omitempty"`
	CreatedByNot           *string             `json:"createdBy_not,omitempty"`
	CreatedByIn            []string            `json:"createdBy_in,omitempty"`
	CreatedByNotIn         []string            `json:"createdBy_not_in,omitempty"`
	CreatedByLt            *string             `json:"createdBy_lt,omitempty"`
	CreatedByLte           *string             `json:"createdBy_lte,omitempty"`
	CreatedByGt            *string             `json:"createdBy_gt,omitempty"`
	CreatedByGte           *string             `json:"createdBy_gte,omitempty"`
	CreatedByContains      *string             `json:"createdBy_contains,omitempty"`
	CreatedByNotContains   *string             `json:"createdBy_not_contains,omitempty"`
	CreatedByStartsWith    *string             `json:"createdBy_starts_with,omitempty"`
	CreatedByNotStartsWith *string             `json:"createdBy_not_starts_with,omitempty"`
	CreatedByEndsWith      *string             `json:"createdBy_ends_with,omitempty"`
	CreatedByNotEndsWith   *string             `json:"createdBy_not_ends_with,omitempty"`
	UpdatedBy              *string             `json:"updatedBy,omitempty"`
	UpdatedByNot           *string             `json:"updatedBy_not,omitempty"`
	UpdatedByIn            []string            `json:"updatedBy_in,omitempty"`
	UpdatedByNotIn         []string            `json:"updatedBy_not_in,omitempty"`
	UpdatedByLt            *string             `json:"updatedBy_lt,omitempty"`
	UpdatedByLte           *string             `json:"updatedBy_lte,omitempty"`
	UpdatedByGt            *string             `json:"updatedBy_gt,omitempty"`
	UpdatedByGte           *string             `json:"updatedBy_gte,omitempty"`
	UpdatedByContains      *string             `json:"updatedBy_contains,omitempty"`
	UpdatedByNotContains   *string             `json:"updatedBy_not_contains,omitempty"`
	UpdatedByStartsWith    *string             `json:"updatedBy_starts_with,omitempty"`
	UpdatedByNotStartsWith *string             `json:"updatedBy_not_starts_with,omitempty"`
	UpdatedByEndsWith      *string             `json:"updatedBy_ends_with,omitempty"`
	UpdatedByNotEndsWith   *string             `json:"updatedBy_not_ends_with,omitempty"`
	Image                  *string             `json:"image,omitempty"`
	ImageNot               *string             `json:"image_not,omitempty"`
	ImageIn                []string            `json:"image_in,omitempty"`
	ImageNotIn             []string            `json:"image_not_in,omitempty"`
	ImageLt                *string             `json:"image_lt,omitempty"`
	ImageLte               *string             `json:"image_lte,omitempty"`
	ImageGt                *string             `json:"image_gt,omitempty"`
	ImageGte               *string             `json:"image_gte,omitempty"`
	ImageContains          *string             `json:"image_contains,omitempty"`
	ImageNotContains       *string             `json:"image_not_contains,omitempty"`
	ImageStartsWith        *string             `json:"image_starts_with,omitempty"`
	ImageNotStartsWith     *string             `json:"image_not_starts_with,omitempty"`
	ImageEndsWith          *string             `json:"image_ends_with,omitempty"`
	ImageNotEndsWith       *string             `json:"image_not_ends_with,omitempty"`
	CreatedAt              *string             `json:"createdAt,omitempty"`
	CreatedAtNot           *string             `json:"createdAt_not,omitempty"`
	CreatedAtIn            []string            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn         []string            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt            *string             `json:"createdAt_lt,omitempty"`
	CreatedAtLte           *string             `json:"createdAt_lte,omitempty"`
	CreatedAtGt            *string             `json:"createdAt_gt,omitempty"`
	CreatedAtGte           *string             `json:"createdAt_gte,omitempty"`
	UpdatedAt              *string             `json:"updatedAt,omitempty"`
	UpdatedAtNot           *string             `json:"updatedAt_not,omitempty"`
	UpdatedAtIn            []string            `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn         []string            `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt            *string             `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte           *string             `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt            *string             `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte           *string             `json:"updatedAt_gte,omitempty"`
	Company                *CompanyWhereInput  `json:"company,omitempty"`
	And                    []ContentWhereInput `json:"AND,omitempty"`
	Or                     []ContentWhereInput `json:"OR,omitempty"`
	Not                    []ContentWhereInput `json:"NOT,omitempty"`
}

type PersonWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Email *string `json:"email,omitempty"`
}

type PersonWhereInput struct {
	ID                    *string            `json:"id,omitempty"`
	IDNot                 *string            `json:"id_not,omitempty"`
	IDIn                  []string           `json:"id_in,omitempty"`
	IDNotIn               []string           `json:"id_not_in,omitempty"`
	IDLt                  *string            `json:"id_lt,omitempty"`
	IDLte                 *string            `json:"id_lte,omitempty"`
	IDGt                  *string            `json:"id_gt,omitempty"`
	IDGte                 *string            `json:"id_gte,omitempty"`
	IDContains            *string            `json:"id_contains,omitempty"`
	IDNotContains         *string            `json:"id_not_contains,omitempty"`
	IDStartsWith          *string            `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string            `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string            `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string            `json:"id_not_ends_with,omitempty"`
	Name                  *string            `json:"name,omitempty"`
	NameNot               *string            `json:"name_not,omitempty"`
	NameIn                []string           `json:"name_in,omitempty"`
	NameNotIn             []string           `json:"name_not_in,omitempty"`
	NameLt                *string            `json:"name_lt,omitempty"`
	NameLte               *string            `json:"name_lte,omitempty"`
	NameGt                *string            `json:"name_gt,omitempty"`
	NameGte               *string            `json:"name_gte,omitempty"`
	NameContains          *string            `json:"name_contains,omitempty"`
	NameNotContains       *string            `json:"name_not_contains,omitempty"`
	NameStartsWith        *string            `json:"name_starts_with,omitempty"`
	NameNotStartsWith     *string            `json:"name_not_starts_with,omitempty"`
	NameEndsWith          *string            `json:"name_ends_with,omitempty"`
	NameNotEndsWith       *string            `json:"name_not_ends_with,omitempty"`
	Email                 *string            `json:"email,omitempty"`
	EmailNot              *string            `json:"email_not,omitempty"`
	EmailIn               []string           `json:"email_in,omitempty"`
	EmailNotIn            []string           `json:"email_not_in,omitempty"`
	EmailLt               *string            `json:"email_lt,omitempty"`
	EmailLte              *string            `json:"email_lte,omitempty"`
	EmailGt               *string            `json:"email_gt,omitempty"`
	EmailGte              *string            `json:"email_gte,omitempty"`
	EmailContains         *string            `json:"email_contains,omitempty"`
	EmailNotContains      *string            `json:"email_not_contains,omitempty"`
	EmailStartsWith       *string            `json:"email_starts_with,omitempty"`
	EmailNotStartsWith    *string            `json:"email_not_starts_with,omitempty"`
	EmailEndsWith         *string            `json:"email_ends_with,omitempty"`
	EmailNotEndsWith      *string            `json:"email_not_ends_with,omitempty"`
	Password              *string            `json:"password,omitempty"`
	PasswordNot           *string            `json:"password_not,omitempty"`
	PasswordIn            []string           `json:"password_in,omitempty"`
	PasswordNotIn         []string           `json:"password_not_in,omitempty"`
	PasswordLt            *string            `json:"password_lt,omitempty"`
	PasswordLte           *string            `json:"password_lte,omitempty"`
	PasswordGt            *string            `json:"password_gt,omitempty"`
	PasswordGte           *string            `json:"password_gte,omitempty"`
	PasswordContains      *string            `json:"password_contains,omitempty"`
	PasswordNotContains   *string            `json:"password_not_contains,omitempty"`
	PasswordStartsWith    *string            `json:"password_starts_with,omitempty"`
	PasswordNotStartsWith *string            `json:"password_not_starts_with,omitempty"`
	PasswordEndsWith      *string            `json:"password_ends_with,omitempty"`
	PasswordNotEndsWith   *string            `json:"password_not_ends_with,omitempty"`
	Company               *CompanyWhereInput `json:"company,omitempty"`
	CreatedAt             *string            `json:"createdAt,omitempty"`
	CreatedAtNot          *string            `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string            `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string            `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string            `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string            `json:"createdAt_gte,omitempty"`
	And                   []PersonWhereInput `json:"AND,omitempty"`
	Or                    []PersonWhereInput `json:"OR,omitempty"`
	Not                   []PersonWhereInput `json:"NOT,omitempty"`
}

type CompanyCreateInput struct {
	ID   *string `json:"id,omitempty"`
	Name string  `json:"name"`
}

type CompanyUpdateInput struct {
	Name *string `json:"name,omitempty"`
}

type CompanyUpdateManyMutationInput struct {
	Name *string `json:"name,omitempty"`
}

type ContentCreateInput struct {
	ID        *string                `json:"id,omitempty"`
	Title     *string                `json:"title,omitempty"`
	Text      string                 `json:"text"`
	Category  string                 `json:"category"`
	Type      string                 `json:"type"`
	Limit     *int32                 `json:"limit,omitempty"`
	Note      *string                `json:"note,omitempty"`
	Opt       *string                `json:"opt,omitempty"`
	CreatedBy *string                `json:"createdBy,omitempty"`
	UpdatedBy *string                `json:"updatedBy,omitempty"`
	Image     *string                `json:"image,omitempty"`
	Company   *CompanyCreateOneInput `json:"company,omitempty"`
}

type CompanyCreateOneInput struct {
	Create  *CompanyCreateInput      `json:"create,omitempty"`
	Connect *CompanyWhereUniqueInput `json:"connect,omitempty"`
}

type ContentUpdateInput struct {
	Title     *string                `json:"title,omitempty"`
	Text      *string                `json:"text,omitempty"`
	Category  *string                `json:"category,omitempty"`
	Type      *string                `json:"type,omitempty"`
	Limit     *int32                 `json:"limit,omitempty"`
	Note      *string                `json:"note,omitempty"`
	Opt       *string                `json:"opt,omitempty"`
	CreatedBy *string                `json:"createdBy,omitempty"`
	UpdatedBy *string                `json:"updatedBy,omitempty"`
	Image     *string                `json:"image,omitempty"`
	Company   *CompanyUpdateOneInput `json:"company,omitempty"`
}

type CompanyUpdateOneInput struct {
	Create     *CompanyCreateInput       `json:"create,omitempty"`
	Update     *CompanyUpdateDataInput   `json:"update,omitempty"`
	Upsert     *CompanyUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                     `json:"delete,omitempty"`
	Disconnect *bool                     `json:"disconnect,omitempty"`
	Connect    *CompanyWhereUniqueInput  `json:"connect,omitempty"`
}

type CompanyUpdateDataInput struct {
	Name *string `json:"name,omitempty"`
}

type CompanyUpsertNestedInput struct {
	Update CompanyUpdateDataInput `json:"update"`
	Create CompanyCreateInput     `json:"create"`
}

type ContentUpdateManyMutationInput struct {
	Title     *string `json:"title,omitempty"`
	Text      *string `json:"text,omitempty"`
	Category  *string `json:"category,omitempty"`
	Type      *string `json:"type,omitempty"`
	Limit     *int32  `json:"limit,omitempty"`
	Note      *string `json:"note,omitempty"`
	Opt       *string `json:"opt,omitempty"`
	CreatedBy *string `json:"createdBy,omitempty"`
	UpdatedBy *string `json:"updatedBy,omitempty"`
	Image     *string `json:"image,omitempty"`
}

type PersonCreateInput struct {
	ID       *string                `json:"id,omitempty"`
	Name     string                 `json:"name"`
	Email    string                 `json:"email"`
	Password string                 `json:"password"`
	Company  *CompanyCreateOneInput `json:"company,omitempty"`
}

type PersonUpdateInput struct {
	Name     *string                `json:"name,omitempty"`
	Email    *string                `json:"email,omitempty"`
	Password *string                `json:"password,omitempty"`
	Company  *CompanyUpdateOneInput `json:"company,omitempty"`
}

type PersonUpdateManyMutationInput struct {
	Name     *string `json:"name,omitempty"`
	Email    *string `json:"email,omitempty"`
	Password *string `json:"password,omitempty"`
}

type CompanySubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *CompanyWhereInput              `json:"node,omitempty"`
	And                        []CompanySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CompanySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CompanySubscriptionWhereInput `json:"NOT,omitempty"`
}

type ContentSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *ContentWhereInput              `json:"node,omitempty"`
	And                        []ContentSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ContentSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ContentSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PersonSubscriptionWhereInput struct {
	MutationIn                 []MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *PersonWhereInput              `json:"node,omitempty"`
	And                        []PersonSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PersonSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PersonSubscriptionWhereInput `json:"NOT,omitempty"`
}

type CompanyExec struct {
	exec *prisma.Exec
}

func (instance CompanyExec) Exec(ctx context.Context) (*Company, error) {
	var v Company
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyExecArray) Exec(ctx context.Context) ([]Company, error) {
	var v []Company
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CompanyFields = []string{"id", "name"}

type Company struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type CompanyConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CompanyConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CompanyConnectionExec) Edges() *CompanyEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CompanyWhereInput", "CompanyOrderByInput", "CompanyEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Company"},
		"node",
		CompanyFields)

	return &CompanyEdgeExecArray{nodes}
}

func (instance *CompanyConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCompany"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CompanyConnectionExec) Exec(ctx context.Context) (*CompanyConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &CompanyConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance CompanyConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyConnectionExecArray) Exec(ctx context.Context) ([]CompanyConnection, error) {
	var v []CompanyConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CompanyConnectionFields = []string{}

type CompanyConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []CompanyEdge `json:"edges"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageInfoFields = []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type CompanyEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CompanyEdgeExec) Node() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"node",
		[]string{"id", "name"})

	return &CompanyExec{ret}
}

func (instance CompanyEdgeExec) Exec(ctx context.Context) (*CompanyEdge, error) {
	var v CompanyEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyEdgeExecArray) Exec(ctx context.Context) ([]CompanyEdge, error) {
	var v []CompanyEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CompanyEdgeFields = []string{"cursor"}

type CompanyEdge struct {
	Node   Company `json:"node"`
	Cursor string  `json:"cursor"`
}

type ContentExec struct {
	exec *prisma.Exec
}

func (instance *ContentExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "name"})

	return &CompanyExec{ret}
}

func (instance ContentExec) Exec(ctx context.Context) (*Content, error) {
	var v Content
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ContentExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ContentExecArray struct {
	exec *prisma.Exec
}

func (instance ContentExecArray) Exec(ctx context.Context) ([]Content, error) {
	var v []Content
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ContentFields = []string{"id", "title", "text", "category", "type", "limit", "note", "opt", "createdBy", "updatedBy", "image", "createdAt", "updatedAt"}

type Content struct {
	ID        string  `json:"id"`
	Title     *string `json:"title,omitempty"`
	Text      string  `json:"text"`
	Category  string  `json:"category"`
	Type      string  `json:"type"`
	Limit     *int32  `json:"limit,omitempty"`
	Note      *string `json:"note,omitempty"`
	Opt       *string `json:"opt,omitempty"`
	CreatedBy *string `json:"createdBy,omitempty"`
	UpdatedBy *string `json:"updatedBy,omitempty"`
	Image     *string `json:"image,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
}

type ContentConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ContentConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ContentConnectionExec) Edges() *ContentEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ContentWhereInput", "ContentOrderByInput", "ContentEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Content"},
		"node",
		ContentFields)

	return &ContentEdgeExecArray{nodes}
}

func (instance *ContentConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateContent"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ContentConnectionExec) Exec(ctx context.Context) (*ContentConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ContentConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ContentConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ContentConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ContentConnectionExecArray) Exec(ctx context.Context) ([]ContentConnection, error) {
	var v []ContentConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ContentConnectionFields = []string{}

type ContentConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []ContentEdge `json:"edges"`
}

type ContentEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ContentEdgeExec) Node() *ContentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Content"},
		"node",
		[]string{"id", "title", "text", "category", "type", "limit", "note", "opt", "createdBy", "updatedBy", "image", "createdAt", "updatedAt"})

	return &ContentExec{ret}
}

func (instance ContentEdgeExec) Exec(ctx context.Context) (*ContentEdge, error) {
	var v ContentEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ContentEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ContentEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ContentEdgeExecArray) Exec(ctx context.Context) ([]ContentEdge, error) {
	var v []ContentEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ContentEdgeFields = []string{"cursor"}

type ContentEdge struct {
	Node   Content `json:"node"`
	Cursor string  `json:"cursor"`
}

type PersonExec struct {
	exec *prisma.Exec
}

func (instance *PersonExec) Company() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"company",
		[]string{"id", "name"})

	return &CompanyExec{ret}
}

func (instance PersonExec) Exec(ctx context.Context) (*Person, error) {
	var v Person
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonExecArray struct {
	exec *prisma.Exec
}

func (instance PersonExecArray) Exec(ctx context.Context) ([]Person, error) {
	var v []Person
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PersonFields = []string{"id", "name", "email", "password", "createdAt"}

type Person struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Email     string `json:"email"`
	Password  string `json:"password"`
	CreatedAt string `json:"createdAt"`
}

type PersonConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PersonConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PersonConnectionExec) Edges() *PersonEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PersonWhereInput", "PersonOrderByInput", "PersonEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Person"},
		"node",
		PersonFields)

	return &PersonEdgeExecArray{nodes}
}

func (instance *PersonConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePerson"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PersonConnectionExec) Exec(ctx context.Context) (*PersonConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &PersonConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance PersonConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PersonConnectionExecArray) Exec(ctx context.Context) ([]PersonConnection, error) {
	var v []PersonConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PersonConnectionFields = []string{}

type PersonConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []PersonEdge `json:"edges"`
}

type PersonEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PersonEdgeExec) Node() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"node",
		[]string{"id", "name", "email", "password", "createdAt"})

	return &PersonExec{ret}
}

func (instance PersonEdgeExec) Exec(ctx context.Context) (*PersonEdge, error) {
	var v PersonEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PersonEdgeExecArray) Exec(ctx context.Context) ([]PersonEdge, error) {
	var v []PersonEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PersonEdgeFields = []string{"cursor"}

type PersonEdge struct {
	Node   Person `json:"node"`
	Cursor string `json:"cursor"`
}

type CompanySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CompanySubscriptionPayloadExec) Node() *CompanyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Company"},
		"node",
		[]string{"id", "name"})

	return &CompanyExec{ret}
}

func (instance *CompanySubscriptionPayloadExec) PreviousValues() *CompanyPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CompanyPreviousValues"},
		"previousValues",
		[]string{"id", "name"})

	return &CompanyPreviousValuesExec{ret}
}

func (instance CompanySubscriptionPayloadExec) Exec(ctx context.Context) (*CompanySubscriptionPayload, error) {
	var v CompanySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CompanySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CompanySubscriptionPayload, error) {
	var v []CompanySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CompanySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type CompanySubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Company     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type CompanyPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CompanyPreviousValuesExec) Exec(ctx context.Context) (*CompanyPreviousValues, error) {
	var v CompanyPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CompanyPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CompanyPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CompanyPreviousValuesExecArray) Exec(ctx context.Context) ([]CompanyPreviousValues, error) {
	var v []CompanyPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CompanyPreviousValuesFields = []string{"id", "name"}

type CompanyPreviousValues struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type ContentSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ContentSubscriptionPayloadExec) Node() *ContentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Content"},
		"node",
		[]string{"id", "title", "text", "category", "type", "limit", "note", "opt", "createdBy", "updatedBy", "image", "createdAt", "updatedAt"})

	return &ContentExec{ret}
}

func (instance *ContentSubscriptionPayloadExec) PreviousValues() *ContentPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ContentPreviousValues"},
		"previousValues",
		[]string{"id", "title", "text", "category", "type", "limit", "note", "opt", "createdBy", "updatedBy", "image", "createdAt", "updatedAt"})

	return &ContentPreviousValuesExec{ret}
}

func (instance ContentSubscriptionPayloadExec) Exec(ctx context.Context) (*ContentSubscriptionPayload, error) {
	var v ContentSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ContentSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ContentSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ContentSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ContentSubscriptionPayload, error) {
	var v []ContentSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ContentSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ContentSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Content     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type ContentPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ContentPreviousValuesExec) Exec(ctx context.Context) (*ContentPreviousValues, error) {
	var v ContentPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ContentPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ContentPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ContentPreviousValuesExecArray) Exec(ctx context.Context) ([]ContentPreviousValues, error) {
	var v []ContentPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ContentPreviousValuesFields = []string{"id", "title", "text", "category", "type", "limit", "note", "opt", "createdBy", "updatedBy", "image", "createdAt", "updatedAt"}

type ContentPreviousValues struct {
	ID        string  `json:"id"`
	Title     *string `json:"title,omitempty"`
	Text      string  `json:"text"`
	Category  string  `json:"category"`
	Type      string  `json:"type"`
	Limit     *int32  `json:"limit,omitempty"`
	Note      *string `json:"note,omitempty"`
	Opt       *string `json:"opt,omitempty"`
	CreatedBy *string `json:"createdBy,omitempty"`
	UpdatedBy *string `json:"updatedBy,omitempty"`
	Image     *string `json:"image,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
}

type PersonSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PersonSubscriptionPayloadExec) Node() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"node",
		[]string{"id", "name", "email", "password", "createdAt"})

	return &PersonExec{ret}
}

func (instance *PersonSubscriptionPayloadExec) PreviousValues() *PersonPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PersonPreviousValues"},
		"previousValues",
		[]string{"id", "name", "email", "password", "createdAt"})

	return &PersonPreviousValuesExec{ret}
}

func (instance PersonSubscriptionPayloadExec) Exec(ctx context.Context) (*PersonSubscriptionPayload, error) {
	var v PersonSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PersonSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PersonSubscriptionPayload, error) {
	var v []PersonSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PersonSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type PersonSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Person      `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PersonPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PersonPreviousValuesExec) Exec(ctx context.Context) (*PersonPreviousValues, error) {
	var v PersonPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PersonPreviousValuesExecArray) Exec(ctx context.Context) ([]PersonPreviousValues, error) {
	var v []PersonPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PersonPreviousValuesFields = []string{"id", "name", "email", "password", "createdAt"}

type PersonPreviousValues struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Email     string `json:"email"`
	Password  string `json:"password"`
	CreatedAt string `json:"createdAt"`
}
